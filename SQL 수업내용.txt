day 1 (16)


-- 1. 테이블의 모든 데이터 가져오기
SELECT * FROM employees;


-- 2. Where 절에 가져올 조건에 맞는 행을 선택한다.
--  위치는 FROM 절 다음에 위치
SELECT * 
FROM 
employees
WHERE department_id = 90;   -- 90번 부서만
SELECT * 
FROM 
employees
WHERE salary = 24000;  --월급이 $24,000인 직원

/*
where 절을 사용할때 주의점
문자(String)과 날짜(Date) 값은 항상 따옴표(')로 표시
문자값은 대소문자를 구분한다. (Case-Sensitive)
날짜값은 날짜포맷에 벗어나지 않도록 (Format-Sensitive)
오라클의 날짜포맷은 RR/MM/DD(RR은 2자리 년도)
*/

-- 3. WHERE + 문자열
SELECT employee_id, first_name, last_name, job_id
FROM employees
WHERE first_name = 'Steven';

-- 4. WHERE + 날씨
SELECT SYSDATE FROM DUAL;
--dual은 샘플테이블 SYSDATE는 현재 날짜 시간


SELECT *
FROM employees
WHERE hire_date = '03/06/17'; --년도/월/날짜


--5. 비교 연산자
SELECT *
FROM employees
WHERE salary >= 10000;   --숫자비교


SELECT *
FROM employees
WHERE hire_date >= '03/06/17';  --날짜비교


SELECT *
FROM employees
WHERE last_name > 'King';  --문자비교 (알파벳순서로 비교)


--예제1)
SELECT *
FROM employees
WHERE employee_id = 100;


--예제2)
SELECT *
FROM employees
WHERE first_name = 'David';


--예제3)
SELECT *
FROM employees
WHERE employee_id <= 105;


--예제4)
SELECT *
FROM job_history
WHERE start_date >= '06/03/03';


--예제5)
SELECT *
FROM departments
WHERE location_id != 1700;   -- <> 이표시도 가능


-- 6. AND OR
SELECT *
FROM employees
WHERE ( department_id = 60 OR 
    department_id = 80) AND salary > 10000;
    

SELECT *
FROM employees
WHERE hire_date > '08/04/04' OR salary > 13000
    AND job_id = 'AD_VP';
    

SELECT *
FROM employees
WHERE (hire_date > '04/01/01' OR salary >5000); -- (hire_date <='04/01/01' AND salary <= 5000);
   
--예제1)
SELECT *
FROM employees
WHERE salary > 4000 AND job_id = 'IT_PROG'; 


--예제2)
SELECT *
FROM employees
WHERE salary > 4000 AND (job_id = 'IT_PROG' OR job_id = 'FI_ACCOUNT'); 


-- IN 연산자
SELECT *
FROM employees
WHERE salary = 4000 OR salary = 3000 OR salary = 2700;


SELECT *
FROM employees
WHERE salary IN ( 4000, 3000, 2700);


예제1)
SELECT *
FROM employees
WHERE salary IN( 10000, 17000, 24000);


예제2)
SELECT *
FROM employees
WHERE department_id NOT IN (30, 50, 80, 100, 110);   -- NOT IN 아닌


-- BETWEEN 연산자
SELECT *
FROM employees
WHERE salary >= 9000 AND salary  <= 10000;


SELECT *
FROM employees
WHERE salary BETWEEN 9000 and 10000;


--예제1)
SELECT *
FROM employees
WHERE salary BETWEEN 10000 and 20000;


--예제2)
SELECT *
FROM employees
WHERE hire_date BETWEEN '04/01/01' and '04/12/30';


--예제3)
SELECT *
FROM employees
WHERE salary NOT BETWEEN  7000 and  17000;






day2

--day 2

--Like 연산자는  _ 와 %를 사용
--%는 문자가 0개 또는 1개 이상
--_는 문자가 1개


SELECT *
FROM employees
WHERE last_name LIKE 'B%';   --대문자 B로 시작하는 이름


SELECT *
FROM employees
WHERE last_name LIKE '%b%';  --이름에 b가 있으면 출력


SELECT *
FROM employees
WHERE first_name LIKE '_d%';   --첫글자 뒤에 d가 나오면


SELECT *
FROM employees
WHERE first_name LIKE '__s%';   --세번째 문자가 s일때


--예제1)

SELECT *
FROM employees
WHERE job_id LIKE '%AD%';


--예제2)

SELECT *
FROM employees
WHERE job_id LIKE '%AD___';


--예제3)

SELECT *
FROM employees
WHERE Phone_number LIKE '%1234';


--예제4)

SELECT *
FROM employees
WHERE Phone_number NOT LIKE '%3%'
                    AND phone_number LIKE '%9';


--예제5)


SELECT *
FROM employees
WHERE job_id LIKE  '%MGR%' 
            OR job_id LIKE '%ASST%';



-- IS NULL / IS NOT NULL


SELECT *
FROM employees
WHERE commission_pct IS NULL;    -- '== NULL (X)'


SELECT *
FROM employees
WHERE commission_pct IS NOT NULL;


--예제1)

SELECT *
FROM employees
WHERE manager_id IS NULL;


-- ORDER BY ( ASC / DESC )

SELECT *
FROM employees
ORDER BY salary ;  --ASC 기본이 오름차순


SELECT *
FROM employees
ORDER BY salary DESC; 


SELECT *
FROM employees
ORDER BY last_name ;  --알파펫 순서도 가능



--멀티 정렬
SELECT employee_id , last_name, department_id
FROM employees
ORDER BY department_id , employee_id DESC;   
--부서번호로 정렬후 사원번호로 정렬



--열을 생성하여 정렬
SELECT employee_id, last_name, salary*12 연봉
FROM employees
ORDER BY 연봉 DESC;


--ORDER BY는 WHERE 절 다음에 위치
SELECT employee_id, last_name, department_id, salary*12 연봉
FROM employees
WHERE department_id = 90
ORDER BY 연봉 DESC;


--예제1)
SELECT employee_id, first_name, last_name
FROM employees
ORDER BY employee_id DESC;


--예제2)
SELECT *
FROM employees
WHERE job_id LIKE '%CLERK%'
ORDER BY salary DESC;


--예제3)
SELECT employee_id, first_name, department_id, salary
FROM employees
WHERE employee_id BETWEEN 120 AND 150
ORDER BY department_id, salary DESC;



--문자형 함수는 대소문자 함수와 문자 조작함수로 나뉜다.


--1. 대소문자 조작 함수(upper, lower, initcap)
SELECT 1+1
FROM DUAL; --듀얼테이블은 연습용 테이블


SELECT LOWER ('SQL COURSE'), UPPER ('SQL COURSE'),
            INITCAP ('SQL COURSE')
FROM DUAL;


-- 문자함수를 WHERE절에 사용
SELECT employee_id, first_name
FROM employees
WHERE UPPER(first_name) = 'PATRICK';


-- 2. 문자조작 함수들
-- CONCAT (문자열을 합침)
SELECT first_name, last_name, CONCAT (first_name, last_name) 풀네임
FROM employees;


--SUBSTR(열이름, m, n) : m은 시작문자, n은 잘라낼 길이
SELECT employee_id, first_name, 
SUBSTR(first_name, 1, 3), 
SUBSTR(first_name, 2, 4), 
SUBSTR(first_name, 2),  --시작부터 끝까지
SUBSTR(first_name, -3)  -- 음수일때 끝(뒤)에서부터 카운트
FROM employees;


--LENGTH: 문자열의 길이
SELECT first_name, LENGTH(first_name)
FROM employees;


--INSTR (문자열, 찾을 문자, m, n)
-- m은 검사 시작 위치
-- n은 찾을 횟수
-- 디폴트값은 m, n 각각 1
SELECT first_name,
INSTR (first_name, 'e', 2), 
INSTR (first_name, 'e', 5), 
INSTR (first_name, 'e', 1, 2)
FROM employees
WHERE first_name = 'Nanette';


--lpad / rpad  (문자열, 자릿수, 채울문자)
SELECT employee_id, first_name, salary,
    LPAD (salary, 10, '#'), RPAD(salary, 10, '*')
FROM employees;

-- 공백을
 이용해 문자열을 분리
SELECT
'홍홍 길동' 성명,
SUBSTR('홍홍 길동',1,INSTR('홍홍 길동', ' ')-1) 성,
SUBSTR('홍홍 길동', INSTR('홍홍 길동', ' ')+1) 이름
FROM DUAL;


--예제1)
SELECT last_name, CONCAT('직업명이 ' , job_id) AS 직업명
FROM employees
WHERE SUBSTR(job_id, 4, 3) = 'REP';  
--job_id의 4번째문자부터 REP 인 경우


SELECT employee_id,
    CONCAT(first_name, last_name) 전체이름,
    last_name,
    LENGTH (last_name) 길이,
    INSTR(last_name, 'a') "'a'가 몇 번째?"
FROM employees;


--문자치환: REPLACE 함수
SELECT job_id, REPLACE(job_id, 'ACCOUNT', 'ACCNT') 적용
FROM employees
WHERE job_id LIKE '%ACCOUNT%';


--예제1)
SELECT last_name 성, LOWER(last_name) LOWER적용, UPPER (last_name) UPPER적용 ,  email 이메일, INITCAP(email) INITCAP적용
FROM employees;


--예제2)
SELECT job_id, SUBSTR(job_id, 1, 2)
FROM employees;



--숫자형함수


--ROUND (반올림)
SELECT ROUND (15.193, 1) 소수첫째자리,
        ROUND (15.193, 2) 소수둘째자리,
        ROUND (15.193, 0) 정수,
        ROUND (15.193  ) 디폴트, 
        ROUND (15.193, -1) "10의자리",
        ROUND (115.193, -2) "100의자리"
FROM DUAL;


--TRUNC (버림)
SELECT TRUNC(15.79, 1) 소수첫째자리,
        TRUNC(15.79, 0) 정수,
        TRUNC(15.79) 디폴트,
        TRUNC(15.79, -1) "10의 자리"
FROM DUAL;


--MOD (나누기후 나머지)
SELECT employee_id 짞수번, last_name 
FROM employees
WHERE MOD(employee_id, 2) = 0
ORDER BY 1;   --1번째 열로 정렬 (오름차순)


--예제1)
SELECT salary,
        ROUND (salary/30) 정수,
        ROUND (salary/30, 1) 소수점첫째자리,
        ROUND (salary/30, -1) "10의 자리"
FROM employees;


-- 날짜형 함수
SELECT  first_name, hire_date  --날짜형식 데이터
FROM employees;


--sysdate 현재 날짜와 시간
SELECT SYSDATE
FROM DUAL;

--날짜 + 숫자 => 날짜
SELECT SYSDATE, SYSDATE+3, SYSDATE-3
FROM DUAL;

-- 날짜 - 날짜 = 총 일수
SELECT employee_id, SYSDATE, hire_date,
    SYSDATE - hire_date, ROUND(SYSDATE - hire_date)
FROM employees;

--시간계산
SELECT SYSDATE + 5/24   --시간 1(하루)
FROM DUAL;

-- MONTHS_BETWEEN : 월을 계산
SELECT employee_id, first_name, 
    ROUND (MONTHS_BETWEEN(SYSDATE, hire_date)),
    (SYSDATE - hire_date)/30
FROM employees;

-- ADD_MONTHS: 달을 더함
SELECT employee_id, first_name, hire_date,
    ADD_MONTHS (hire_date, 4)   --4달 더하기
FROM employees;


--NEXT_DAY (날짜, 다음번 나올 요일)
SELECT SYSDATE, NEXT_DAY (SYSDATE, '화요일')
FROM DUAL;


--LAST_DAY(날짜) : 그 월의 마지막 날
SELECT LAST_DAY (SYSDATE)
FROM DUAL;


--날짜의 반올림
SELECT employee_id, hire_date,
    ROUND(hire_date, 'MONTH') 월,  --날에서 반올림  1일
    ROUND(hire_date, 'YEAR') 년   --월에서 반올림 1얼 1일
    
FROM employees
WHERE MONTHS_BETWEEN (SYSDATE, hire_date) < 150;

--예제1)
SELECT SYSDATE, HIRE_DATE, MONTHS_BETWEEN (SYSDATE, hire_date)
FROM employees
WHERE department_id = 100;

--예제2)
SELECT hire_date, ADD_MONTHS (hire_date, 3) , ADD_MONTHS (hire_date, -3)
FROM employees
WHERE employee_id BETWEEN 100 AND 106;





--Day 3



--변환형 함수

--TO_CHAR
--숫자를 문자로 변환
--콤마(,)
SELECT TO_CHAR(12345678, '999,999,999') 콤마
FROM DUAL;  --숫자지만 문자형으로 출력


--소수점(.)
SELECT TO_CHAR(123.45678, '999,999,999.99') 소수점
FROM DUAL;


--$표시
SELECT TO_CHAR(12345678, '$999,999,999') 달러표시
FROM DUAL;


--L표시
SELECT TO_CHAR(12345678, 'L999,999,999') 현지통화
FROM DUAL;


--왼쪽에 0을 삽입
SELECT TO_CHAR(123, '09999') 제로표시 -- 남는 공간을 0으로 표시
FROM DUAL;


--날짜를 문자로 변환
--년,월,일,시,분,초
SELECT TO_CHAR(SYSDATE, 'YY-MM-DD HH24:MI:SS') 현재날짜시간
FROM DUAL;


--365일중 오늘이 몇일?
SELECT TO_CHAR(SYSDATE, 'DDD') 날짜
FROM DUAL;


--오늘의 월?
SELECT TO_CHAR(SYSDATE, 'MONTH') 몇월
FROM DUAL;


--예제1)
SELECT employee_id, TO_CHAR(hire_date, 'MM/YY') 입사월
FROM employees
WHERE department_id = 100;


--예제2)
SELECT last_name 이름, TO_CHAR(salary, '999,999.99') 월급
FROM employees
WHERE salary > 10000
ORDER BY salary DESC;


-- 문자를 날짜로 TO_DATE
SELECT TO_DATE('2011-01-01', 'YYYY-MM-DD')
FROM DUAL;


--문자를 숫자로 TO_NUMBER
SELECT TO_NUMBER('0123123') + 100
FROM DUAL;



-- NULL 관련 함수
--NVL : 널값을 다른 값으로 바꿀때 사용
SELECT last_name, manager_id, NVL(manager_id, 0) 매니저   --NULL값을 0으로 바꿈
FROM employees
WHERE last_name = 'King';


--NVL2( ex, ex1, ex2) : ex값이 NULL값이 아니면 ex1, NULL값이면 ex2
SELECT last_name,  NVL2(manager_id, 1, 0)  매니저  
FROM employees
WHERE last_name = 'King';


--NULLIF (ex1, ex2) : ex1과 ex2값이 동일하면 NULL
-- 동일하지 않으면 ex1으로 출력
SELECT NULLIF(1, 1), NULLIF(1,2)
FROM DUAL;


--COALESCE (ex1, ex2, ex3, ...)
--ex1이 널값이면 ex2 반환, ex2도 널값이면 ex3반환...
SELECT last_name 이름, salary 월급, commission_pct 커미션pct, COALESCE((salary + (commission_pct*salary)), salary+2000) 월급인상
FROM employees
ORDER BY 3;


--예제1)
SELECT last_name 이름, salary 월급, NVL(commission_pct, 0) 커미션, salary*12 + salary*12*NVL(commission_pct, 0) 연봉
FROM employees
ORDER BY 연봉 DESC;


--예제2)
SELECT last_name 이름, salary 월급, NVL(commission_pct, 0) 커미션, salary*12 + salary*12*NVL(commission_pct, 0) 연봉,
        NVL2 (commission_pct, 'SAL+COMM', 'SAL') 연봉계산
FROM employees
ORDER BY 연봉 DESC;



--예제3)
SELECT first_name, LENGTH(first_name) 글자수1, last_name, LENGTH(last_name) 글자수2, 
        NULLIF(LENGTH(first_name), LENGTH(last_name)) 결과
FROM employees;



--DECODE 함수 : DECODE(ex1, 'ex2', ex3) ex1안에서 ex2(조건)이면 ex3로 
SELECT last_name 이름, job_id, salary, DECODE(job_id, 'IT_PROG', salary*1.10, 'ST_CLECRK', salary*1.15, 'SA_REP', salary*1.20,
                salary) 수정월급
FROM employees;


--예제1)
SELECT last_name 이름, job_id 직무, salary 월급, 
        DECODE(TRUNC(salary/2000), 0, 0,
                                    1, 0.09,
                                    2, 0.20,
                                    3, 0.30,
                                    4, 0.40,
                                    5, 0.42,
                                    6, 0.44,
			   0.45) 세율
              
FROM employees;


--CASE 함수는 조건연산자를 다 사용할수 있음 IF, THEN, ELSE구문과 비슷
-- ex) CASE job_id WHEN 'IT_PROG' THEN salary*1.10
--              WHEN 'ST_CLERK' THEN salary*1.15  ..


--예제1)
SELECT employee_id, first_name, last_name, salary,
        CASE WHEN salary >= 9000  THEN '상위급여'
             WHEN salary BETWEEN 6000 AND 8999   THEN '중위급여'
             ELSE                               '하위급여'
             END "급여등급"

FROM employees
WHERE job_id = 'IT_PROG';



--그룹함수
SELECT COUNT(*) --직원테이블의 모든행의 개수
FROM employees;


SELECT salary
FROM employees
ORDER BY salary DESC;


--MAX MIN
SELECT MAX(salary), MIN(salary)
FROM employees;


--문자열에 적용
SELECT MAX(first_name), MIN(first_name)
FROM employees;


--날짜에 적용
SELECT MAX(hire_date), MIN(hire_date)
FROM employees;


-- SUM, AVG : 합계와 평균 (숫자만 가능)
SELECT SUM(salary), AVG(salary)
FROM employees;


-- COUNT
SELECT COUNT(commission_pct) --NULL값이 아닌 행의 개수
FROM employees;


SELECT COUNT(NVL(commission_pct, 0)) --NULL값을 포함
FROM employees;


SELECT COUNT(department_id) 
FROM employees;


SELECT COUNT(DISTINCT(department_id)) -- 부서의 개수 (중복 허용x)
FROM employees;


--90번 부서의 직원의 숫자
SELECT COUNT(employee_id) 
FROM employees
WHERE department_id = 90;


SELECT AVG(commission_pct) --널값은 제외한 평균
FROM employees;



--GROUP BY로 나눠서 집계함수 사용
SELECT department_id , ROUND(AVG(salary)) 평균급여
FROM employees
GROUP BY department_id;


SELECT department_id 부서번호, ROUND(AVG(salary)) 평균급여,
        SUM(salary) 총급여합계, COUNT(*) 부서인원수
FROM employees
GROUP BY department_id;


SELECT department_id 부서번호, ROUND(AVG(salary)) 평균급여, job_id 직업,
        SUM(salary) 총급여합계, COUNT(*) 부서인원수
FROM employees
GROUP BY department_id, job_id;


--예제1)
SELECT department_id 부서명, COUNT(*) 사원수, MAX(salary) 최고급여, MIN(salary) 최소급여, SUM(salary) 급여합계, ROUND(AVG(salary)) 평균급여
FROM employees
GROUP BY department_id
ORDER BY 평균급여 DESC;


--예제2)
SELECT department_id 부서번호, job_id 직업, manager_id 상사번호, SUM(salary) 월급합계, COUNT(*) 직원수
FROM employees
GROUP BY department_id, job_id, manager_id
ORDER BY 부서번호 ASC;


--예제3)
SELECT ROUND(AVG(MAX(salary))) 부서별최고월급평균, AVG(MIN(salary)) 부서별최저월급평균
FROM employees
GROUP BY department_id;



-- HAVING 절 : GOURP BY함수에 조건을 추가함
SELECT department_id 부서번호, SUM(salary) 급여합계
FROM employees
GROUP BY department_id
HAVING SUM(salary) > 100000
ORDER BY department_id;


--예제1)
SELECT job_id 직종, SUM(salary) 월급여합계
FROM employees
WHERE job_id != 'AC_MGR'  --일반조건
GROUP BY job_id
HAVING AVG(salary) > 10000   --그룹함수 조건
ORDER BY job_id DESC;


--예제2)
SELECT department_id 부서번호, ROUND(AVG(salary))
FROM employees
WHERE department_id <> 40
GROUP BY department_id
HAVING AVG(salary) <= 7000;



--예제3)
SELECT job_id, SUM(salary) 급여총액
FROM employees
WHERE job_id NOT LIKE '%REP%'   --REP가 있는 직종 제외
GROUP BY job_id
HAVING SUM(salary) >= 13000
ORDER BY 급여총액 DESC;




--DAY4



--JOIN 함수
SELECT e.employee_id, e.department_id, d.department_name
FROM employees e
JOIN departments d
    ON e.department_id = d.department_id;
    
    
    
--NATURAL JOIN 함수 : ON 절 생략
SELECT employee_id, first_name, job_id, job_title
FROM employees
NATURAL JOIN jobs;



--기본 동등조인
SELECT e.employee_id, j.job_id, j.job_title
FROM employees e
JOIN jobs j
    ON e.job_id = j.job_id;
    
    
--WHERE절 추가
SELECT e.employee_id, e.department_id, d.department_name
FROM employees e
JOIN departments d
    ON e.department_id = d.department_id
WHERE d.department_id = 50;



--3개 테이블 조인
SELECT e.employee_id, d.department_name, lo.city
FROM employees e
JOIN departments d  ON e.department_id = d.department_id
JOIN locations lo   on d.location_id = lo.location_id;


--예제1)
SELECT d.department_name 부서명, lo.city 도시명, c.country_name 국가명
FROM departments d
JOIN locations lo ON d.location_id = lo.location_id
JOIN countries c ON lo.country_id = c.country_id
WHERE (lo.city = 'Seattle' OR lo.city = 'London') AND c.country_name LIKE 'United%'
ORDER BY 2;



--자체조인
SELECT e.last_name 직원, e.employee_id 직원번호, m.last_name 매니저, m.employee_id 직원번호2
FROM employees e
JOIN employees m
    ON e.manager_id = m.employee_id;;;;;;;;;;;;;;;;;;;;;;;;;
    

SELECT employee_id, last_name, manager_id
FROM employees
WHERE last_name = 'Kumar';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;





-- SCOTT문제 40개



--SCOTT 문제1)
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE DEPTNO = 10;


--문제2)
SELECT ENAME, HIREDATE, DEPTNO
FROM EMP
WHERE EMPNO = 7369;


--문제3)
SELECT *
FROM EMP
WHERE ENAME = 'ALLEN';


--문제4)
SELECT ENAME, DEPTNO, SAL
FROM EMP
WHERE HIREDATE = '81/02/20';


--문제5)
SELECT *
FROM EMP
WHERE JOB <> 'MANAGER';


--문제6)
SELECT *
FROM EMP
WHERE HIREDATE >= '81/04/02';



--문제7)
SELECT ENAME, SAL, DEPTNO
FROM EMP
WHERE SAL >= 800;



--문제8)
SELECT *
FROM EMP
WHERE DEPTNO >= 20;



--문제9)
SELECT *
FROM EMP
WHERE ENAME > 'L';



--문제10)
SELECT *
FROM EMP
WHERE HIREDATE < '81/12/09';


--문제11)
SELECT EMPNO, ENAME
FROM EMP
WHERE EMPNO <= 7698;;;;;


--문제12)
SELECT ENAME, SAL, DEPTNO
FROM EMP
WHERE HIREDATE >= '81/04/02' AND HIREDATE <= '82/12/09';


--문제13)
SELECT ENAME, JOB, SAL
FROM EMP
WHERE SAL > 1600 AND SAL <3000;


--문제14)
SELECT *
FROM EMP
WHERE EMPNO NOT BETWEEN '7654' AND '7782';


--문제15)
SELECT *
FROM EMP
WHERE ENAME BETWEEN 'B' AND 'J';


--문제16)
SELECT *
FROM EMP
WHERE HIREDATE NOT LIKE '81/%%/%%';

SELECT *
FROM EMP
WHERE TO_CHAR(HIREDATE, 'YYYY') <> '1981';


--문제17)
SELECT *
FROM EMP
WHERE JOB = 'MANAGER' OR JOB = 'SALESMAN';


--문제18)
SELECT ENAME, EMPNO, DEPTNO
FROM EMP
WHERE DEPTNO NOT LIKE 20 AND DEPTNO NOT LIKE 30;


--문제19)
SELECT EMPNO, ENAME, HIREDATE, DEPTNO
FROM EMP
WHERE ENAME LIKE 'S%';


--문제20)
SELECT *
FROM EMP
WHERE HIREDATE LIKE '81/%%/%%';


--문제21)
SELECT *
FROM EMP
WHERE ENAME LIKE '%S%';


--문제22)
SELECT *
FROM EMP
WHERE ENAME LIKE 'M____N';


--문제23)
SELECT *
FROM EMP
WHERE ENAME LIKE '_A%';


--문제24)
SELECT *
FROM EMP
WHERE COMM IS NULL;


--문제25)
SELECT *
FROM EMP
WHERE COMM IS NOT NULL;


--문제26)
SELECT ENAME, DEPTNO, SAL
FROM EMP
WHERE DEPTNO = 30 AND SAL >= 1500;


--문제27)
SELECT EMPNO, ENAME, DEPTNO
FROM EMP
WHERE ENAME LIKE 'K%' OR DEPTNO = '30';


--문제28)
SELECT *
FROM EMP
WHERE JOB LIKE 'MANAGER' AND(SAL >= 1500 AND DEPTNO = '30');


--문제29)
SELECT *
FROM EMP
WHERE DEPTNO ='30'
ORDER BY DEPTNO;


--문제30)
SELECT *
FROM EMP
ORDER BY SAL DESC;


--문제31)
SELECT *
FROM EMP
ORDER BY DEPTNO ASC; AND SAL DESC;


--문제32)
SELECT DEPTNO, ENAME, SAL
FROM EMP
ORDER BY DEPTNO DESC; AND (ENAME ASC AND SAL DESC);


--문제33)
SELECT ENAME, SAL, ROUND(SAL*0.13) BONUS, DEPTNO
FROM EMP
WHERE DEPTNO = '10';


--문제34)
SELECT ENAME, SAL, NVL(COMM, 0) COMM1, NVL(COMM, 0)+SAL TOTAL
FROM EMP
ORDER BY TOTAL DESC;


--문제35)
SELECT ENAME, SAL, TO_CHAR(SAL*0.15, '$999.9') 회비
FROM EMP
WHERE SAL BETWEEN 1500 AND 3000;


--문제36)
SELECT D.DNAME, COUNT(E.EMPNO)
FROM EMP E
JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO
GROUP BY D.DNAME
HAVING COUNT(E.EMPNO) > '5';


--문제37)
SELECT JOB, SUM(SAL) 급여합계
FROM EMP E
WHERE JOB != 'SALESMAN'
GROUP BY JOB
HAVING SUM(SAL) > 5000
ORDER BY SUM(SAL) DESC;


--문제38) 비동등조인 SALARYGRADE 테이블 
SELECT E.EMPNO, E.ENAME, E.SAL, S.GRADE
FROM EMP E
JOIN SALGRADE S
    ON E.SAL BETWEEN S.LOSAL AND S.HISAL;
    
    
--문제39)
SELECT DEPTNO, COUNT(*) AS "사원수", COUNT(COMM) AS "커미션 받은 사원수"
FROM EMP
GROUP BY DEPTNO;


--문제40)
SELECT ENAME, DEPTNO, DECODE( DEPTNO, '10', '총무부', '20', '개발부', '30', '영업부') 부서명
FROM EMP;






--day5





--외부조인 (OUTER JOIN) : 조인 조건에 일치하지 않는 데이터까지 모두 출력해준다.


--LEFT OUTER JOIN
SELECT e.last_name 직원, e.department_id 부서번호, d.department_name 부서명
FROM employees e
LEFT OUTER JOIN departments d
    ON e.department_id = d.department_id;


--RIGHT OUTER JOIN
SELECT e.last_name 직원, e.department_id 부서번호, d.department_name 부서명
FROM employees e
RIGHT OUTER JOIN departments d
    ON e.department_id = d.department_id;


--FULL OUTER JOIN : 왼쪽 오른쪽 둘다 나오게
SELECT e.last_name 직원, e.department_id 부서번호, d.department_name 부서명
FROM employees e
FULL OUTER JOIN departments d
    ON e.department_id = d.department_id;



--예제1)
SELECT c.country_name 국가, c.country_id 국가번호, l.location_id 지역번호, l.city 도시
FROM countries c
LEFT OUTER JOIN locations l
    ON c.country_id = l.country_id
ORDER BY 3 DESC;  -- l.location_id 대신 3 넣어도 돼.



--CROSS JOIN : 한 쪽 테이블의 모든 행들과 다른 테이블의 모든 행을 연결시키는 기능


--예제)
SELECT c.country_name 국가, r.region_name 지역이름
FROM countries c
CROSS JOIN regions r;



--리뷰 예제
--1
SELECT d.department_name 부서명, d.manager_id 매니저번호, 
        e.last_name||' '||e.first_name 풀네임, e.phone_number 폰번호   
FROM departments d
JOIN employees e
    ON d.manager_id = e.employee_id;


--2 : 조인을 이용하여 사원들의 직원번호(employee_id), 고용일자(hire_date), 직종(job_id), 직책(job_title)을 출력하시오.
SELECT *
FROM employees e
JOIN jobs j
    ON e.job_id = j.job_id;
    
    
--3 : 직책(job_title)이 'Sales Manger'인 사원들의 입사년도 그룹 별 평균 급여를 출력하시오.
    -- 입사년도를 기준으로 오름차순 정렬 (jobs 테이블과 조인 job_id를 이용, 입사년도:TO_CHAR(e.hire_date, 'YYYY'))
SELECT TO_CHAR(e.hire_date, 'YYYY') 입사년도, ROUND(AVG(e.salary)) 평균급여
FROM employees e
JOIN jobs j
    ON j.job_id = e.job_id
WHERE job_title LIKE 'Sales Manager'
GROUP BY TO_CHAR(e.hire_date, 'YYYY')
ORDER BY 1 ASC;


--4 : 각가의 도시(city)에 있는 모든 부서 직원들의 평균급여를 조회하고자 한다. 평균급여가 가장 낮은 도시부터 도시명(city)
    --과 평균연봉, 해당 도시의 직원수를 출력하시오. 단, 도시에 근무하는 직원이 10명 이상인 곳은 제외하고 조회하시오.
    --(Tips: 테이블 관계도를 보고 우선 어떤 테이블을 조인해야 할지 결정한후 SELEC*에 테이블을 조인해서 문제가 없는지
    --확인한후 GROUP BY절과 SELECT 절 작성)
SELECT l.city, ROUND(AVG(e.salary)), COUNT(*)
FROM locations l
JOIN departments d
    ON l.location_id = d.location_id
JOIN employees e
    ON d.department_id = e.department_id
GROUP BY l.city
HAVING COUNT(*) < 10
ORDER BY 2;


--5 : 자신의 매니저 보다 급여를 많이 받는 직원들의 성(last_name), 급여(salary)와 매니저의 last_name과 salary를 출력하라.
SELECT e.employee_id, e.last_name, e.salary, m.last_name, m.salary
FROM employees e
JOIN employees m
    ON e.manager_id = m.employee_id
WHERE e.salary > m.salary;




--서브쿼리



--Abel 직원보다 급여를 더 많이 받는 직원들은?
--Abel의 급여 확인
SELECT salary
FROM employees
WHERE last_name = 'Abel';

--서브쿼리를 사용
-- 단일행 연산자 ( =, >, <, <=, =>, <>, != )
SELECT employee_id, last_name, salary
FROM employees
WHERE salary > (SELECT salary
                FROM employees
                WHERE last_name = 'Abel');
                
--에러가 나는 경우
SELECT employee_id, last_name, salary
FROM employees
WHERE salary > (SELECT salary
                FROM employees
                WHERE department_id = 30);
                
--그룹함수를 서브쿼리로 이용
--그룹함수 예로 MAX는 가장높은 급여를 받는 사람을 알수없음
SELECT *
FROM employees
WHERE salary = (SELECT MAX(salary) FROM employees);


--예제1) 사원'Abel'(last_name)보다 급여가 많은 사원의 last_name, salary를 나타내어라(서브쿼리 사용)
SELECT last_name, salary
FROM employees
WHERE salary > (SELECT salary FROM employees WHERE last_name = 'Abel');


--예제2) 'Bull'이란 last_name을 가진 사원의 부서에서 Bull보다 높은 급여를 받는 사원들을 출력하라. (서브쿼리 사용)
SELECT employee_id 직원번호, last_name 이름, department_id 부서번호, salary 급여
FROM employees
WHERE department_id = (SELECT department_id FROM employees WHERE last_name ='Bull')
    AND salary > (SELECT salary FROM employees WHERE last_name='Bull');
    
    
--예제3) 'Russell'이란 last_name의 직원번호를 manager_id로 가지는 직원들의 last_name, salary, manager_id를 출력하시오.
SELECT last_name, salary, manager_id
FROM employees
WHERE manager_id = (SELECT employee_id FROM employees WHERE last_name = 'Russell');


--예제4) jobs 테이블에 job_title이 'Stock Manager'의 job_id를 가진 직원들의 정보를 Employees 테이블에서 찾아서 출력하시오.
SELECT *
FROM employees
WHERE job_id = (SELECT job_id FROM jobs WHERE job_title = 'Stock Manager');



-- 다중행 서브쿼리
-- 연산자 (IN, ANY, ALL)
SELECT salary FROM employees WHERE department_id = 90;



-- IN 연산자 : 검색된 값 중에 하나만 일치하면 참이다.(여러개의 '=')
SELECT employee_id, first_name, last_name, salary
FROM employees 
WHERE salary IN
            (SELECT salary FROM employees WHERE department_id = 90);
            
            
-- ANY 연산자: 검색된 값 중에 조건에 맞는 것이 하나 이상 있으면 참이다.
-- 비교연산자 ( > , <, =>, <= 등등)가 있어야 한다.
SELECT employee_id, first_name, last_name, salary
FROM employees
WHERE salary >= ANY (SELECT salary FROM employees WHERE department_id = 90);


-- ALL 연산자: 모든 검색된 값과 조건에 맞아야 한다.
-- 비교연산자 ( > , <, =>, <= 등등)가 있어야 한다.
SELECT employee_id, first_name, last_name, salary
FROM employees
WHERE salary < ALL (SELECT salary FROM employees WHERE job_id = 'IT_PROG');


--예제1) 부서번호(department_id)가 20번인 직원들의 매니저아이디(manager_id)와 같은 매니저를 가지는 직원들을
--출력하시오 (단 20번 부서의 직원은 제외!)
SELECT employee_id, first_name, job_id 직종, salary 급여
FROM employees
WHERE manager_id IN (SELECT manager_id FROM employees WHERE department_id = 20)
                AND department_id NOT LIKE  20;


--예제2) job_id가 'ST_MAN'인 직원들중 어느 한직원 보다도 급여가 작은 직원들을 출력하시오(ANY)
SELECT employee_id, last_name, job_id, salary
FROM employees
WHERE salary < ANY (SELECT salary FROM employees WHERE job_id = 'ST_MAN');


--예제3) 직책이 'IT_PROG'인 직원들 보다 급여가 작은 직원들을 출력하시오 (ALL)
SELECT employee_id, last_name, job_id, salary
FROM employees
WHERE salary < ALL (SELECT salary FROM employees WHERE job_id = 'IT_PROG');




--다중열 서브쿼리 : 여러 개의 컬럼을 검색하는 서브 쿼리
SELECT employee_id, first_name, job_id, salary, manager_id
FROM employees
WHERE (manager_id, job_id) IN (SELECT manager_id, job_id FROM employees WHERE first_name = 'Bruce')
AND first_name <> 'Bruce';


--부서별로 최소 급여를 받는 사원의 부서번호, 사원번호, 이름, 급여 정보 검색
SELECT department_id 부서번호, employee_id 사원번호, first_name 이름, salary 급여
FROM employees
WHERE (department_id, salary) IN (SELECT department_id, MIN(salary)
                                    FROM employees
                                    GROUP BY department_id)
ORDER BY department_id;



--예제) : employees 테이블에서 job_id별로 가장 낮은 salary가 얼마인지 찾아보고, 찾아낸 job_id별 salary에 해당하는
--직원이 first_name, job_id, salary, department_id를 출력하시오. (salary내림차순 정렬)
SELECT first_name, job_id, salary, department_id
FROM employees
WHERE (job_id, salary) IN (SELECT job_id, MIN(salary) FROM employees GROUP BY job_id)
ORDER BY salary DESC;






--집합연산자 (UNION, UNION ALL, INTERSECT, MINUS)
--두 설렉문의 데이터 타입은 일치해야한다.




--UNION : 합집합 중복제거 (115행)
SELECT employee_id, job_id
FROM employees
UNION
SELECT employee_id, job_id
FROM job_history;


--UNION ALL : 합집합 중복포함 (117행)
SELECT employee_id, job_id
FROM employees
UNION ALL
SELECT employee_id, job_id
FROM job_history;


--INTERSECT : 교집합 (2행)
SELECT employee_id, job_id
FROM employees
INTERSECT
SELECT employee_id, job_id
FROM job_history;


--MINUS : 차집합 (105행)
SELECT employee_id, job_id
FROM employees
MINUS
SELECT employee_id, job_id
FROM job_history;


--예제1) employees 테이블의 department_id 집합과 departments 테이블의 department_id 집합을 UNION 연산자를 이용해 합쳐 보세요.
SELECT department_id
FROM employees
UNION
SELECT department_id
FROM departments;


--예제2) employees 테이블의 department_id 집합과 departments 테이블의 department_id 집합을 UNION ALL 연산자를 이용해 합쳐 보세요.
SELECT department_id
FROM employees
UNION ALL
SELECT department_id
FROM departments;



--예제3) employees 테이블의 department_id 집합과 departments 테이블의 department_id 집합의 ㄱ집합을 INTERSECT연산자를 이용해 출력해 보세요.
SELECT department_id
FROM employees
INTERSECT
SELECT department_id
FROM departments;


--예제4) employees 테이블의 department_id 집합과 departments 테이블의 department_id 집합의 ㄱ집합을 MINUS연산자를 이용해 출력해 보세요.
SELECT department_id
FROM departments
MINUS
SELECT department_id
FROM employees;




--day 6






--DML 작업 : 데이터베이스에 데이터를 입력, 수정, 삭제하는 명령어이다.
--데이터베이스의 내용을 변경하는 작업을 수행함으로 주의깊게 실행해야 한다.

--INSERT: 새 행을 입력하기
--1. 실행전 열과 제약조건을 확인 (DESC + 테이블)
DESC departments;   --describe 약자 (요약)


--전체 열을 다 입력하는 방법 1
INSERT INTO departments (department_id, department_name, manager_id, location_id)
VALUES ( 71, '개발부 1', 100, 1700);

SELECT *
FROM departments;

commit;

--열의 이름이 없는 경우 전체 열을 다 입력해야 함
INSERT INTO departments
VALUES (72, '개발부 2', 100, 1700);

COMMIT;

--열의 순서를 바꿀경우
INSERT INTO departments (department_name, manager_id, locations_id, department_id)
VALUES ('개발부 3', 100, 1700, 73);

COMMIT;


--자동으로 널값 입력
INSERT INTO departments (department_id, department_name )
VALUES (74, '개발부 4');
COMMIT;
DESC departments;


--SYSDATE 현재 날짜 입력
INSERT INTO employees (employee_id, first_name, last_name, email, hire_date, job_id)
VALUES (1, '길동', '홍', 'hong@naver.com', SYSDATE, 'IT_PROG');
COMMIT;

SELECT*
FROM employees;

DESC employees;


--날짜 입력하기
INSERT INTO employees (employee_id, first_name, last_name, email, hire_date, job_id)
VALUES (2, '길동', '강', 'kang@naver.com', TO_DATE('2020-04-05','YYYY-MM-DD'), 'IT_PROG');
COMMIT;


--사용자로부터 직접입력받기
INSERT INTO department (department_id, department_name )
VALUES (&id, '&name');  -- 75 개발부 5
COMMIT;



--테이블 만들기
CREATE TABLE XX_EMP (
    EMPNO NUMBER,
    ENAME VARCHAR2(100),
    SAL    NUMBER);
 
--테이블 전체를 카피해서 입력하는 방법    
INSERT INTO XX_EMP (EMPNO, ENAME, SAL)
SELECT employee_id, first_name, salary
FROM employees;


-- INSERT를 실행중에 에러가 나는 경우
-- 기본키에 이미 있는 (중복된) 값을 입력할 경우
INSERT INTO departments (department_id, department_name, manager_id, locatoin_id )
VALUES (10, '개발부 10', 100, 1700); 


--2 FK(외래키)에 참조되지 않은 값을 입력
INSERT INTO departments (department_id, department_name, manager_id, locatoin_id )
VALUES (5, '개발부 5', 100, 1); 


--3 데이터의 종류가 다를때
INSERT INTO departments (department_id, department_name, manager_id, locatoin_id )
VALUES (5, '개발부 5', 100, 'D1'); 


--4 데이터의 사이즈가 맞지 않을때
INSERT INTO departments (department_id, department_name, manager_id, locatoin_id )
VALUES (5, '개발부 5개발부 5개발부 5개발부 5개발부 5개발부 5개발부 5개발부 5', 100, 'D1'); 


--5 테이블을 카피하기
CREATE TABLE COPY_DEPT
AS
SELECT * FROM departments;


--예제1)
-- departments 테이블에 다음과 같이 각각의 depatment_id, department_name,
--manager_id가 200, location_id가 1700인 행을 3개 입력하세요.
INSERT INTO departments (department_id, department_name, manager_id, location_id)
VALUES (271, 'Sample Dept 1', 200, 1700);

INSERT INTO departments (department_id, department_name, manager_id, location_id)
VALUES (272, 'Sample Dept 2', 200, 1700);

INSERT INTO departments (department_id, department_name, manager_id, location_id)
VALUES (273, 'Sample Dept 3', 200, 1700);
COMMIT;


--예제2)
--아래와 같이 테이블을 만든후 SELECT문을 이용하여 departments 테이블 내용을 전부 입력하시오.
CREATE TABLE copy_departments ( department_id number(4,0),
                                department_name varchar2(30 byte),
                                manager_id number(6,0),
                                location_id number(4,0));
                            
INSERT INTO copy_departments
SELECT * FROM departments;




-- UPDATE: 데이터 수정하기


--업데이트 사용시 WHERE 절에 항상 기본키를 활용한다.
CREATE TABLE copy_emp
AS
SELECT * FROM employees;

UPDATE copy_emp
SET salary = 24100
WHERE employee_id = 100;
COMMIT;


--의도치 않게 이름이 같은 사람이 업데이트됨
UPDATE copy_emp
SET salary = 24100
WHERE first_name = 'Steven';
COMMIT;


--WHERE 절을 안썼을때
UPDATE copy_emp
SET phone_number = '123-456-789';
ROLLBACK;


--예제1) 
--copy_dept 테이블의 '개발부 4, 5'부서의 매니저와 location ID를 업데이트 해보자.
UPDATE copy_dept
SET manager_id = 100, location_id = 1800
WHERE department_id = 74;

UPDATE copy_dept
SET manager_id = 100, location_id = 1800
WHERE department_id = 5;


INSERT INTO copy_dept ( department_id, department_name, manager_id, location_id)
VALUES (280, 'Music', 100, 1800);


--예제2)
-- copy_dept  테이블에서 department_id 150부터 200까지 부서번호의 manager_id를 100으로 수정하라.
UPDATE copy_dept
SET manager_id = 100
WHERE department_id BETWEEN 150 AND 200;



--DELETE 데이터 삭제


-- WHERE 절의 조건에 해당하는 행단위로 데이터를 삭제한다
-- 테이블을 삭제해도 테이블의 물리적인 구조는 변하지 않는다.

--71번~75번 부서번호 삭제
DELETE FROM departments
WHERE department_id BETWEEN 71 AND 75;
COMMIT;


--employees 테이블 id 1번 2번 삭제
DELETE FROM employees
WHERE employee_id IN (1, 2);
COMMIT;


--테이블 전체 삭제 : 테이블은 그대로 있고 데이터만 삭제 ( ROLLBACK 가능)
DELETE FROM copy_departments;
ROLLBACK;


--TRUNCATE : 전체 삭제(ROLLBACK 불가능)
TRUNCATE TABLE copy_departments;
ROLLBACK;


--DROP TABLE : 테이블 삭제
DROP TABLE copy_departments;
DROP TABLE copy_dept;
DROP TABLE xx_emp;


--SAVE POINT(세이브 포인트) : 중간저장 (ROLLBACK TO SAVEPOINT하면 savepoint 상태로 돌아옴)
SELECT * FROM copy_emp
WHERE employee_id = 108;  --salary 12008

UPDATE copy_emp
SET salary = salary + 10
WHERE employee_id = 108;
-- salary 값이 12018
-- 세이브 포인트 만들기
SAVEPOINT A;


UPDATE copy_emp
SET salary = salary + 20
WHERE employee_id = 108;


--세이브포인트로 롤백
ROLLBACK TO SAVEPOINT A;
--salary 값이 12018
--롤백
ROLLBACK;

COMMIT;




--DATETYPE : 데이터 타입(자료형)이란 컴퓨터 시스템과 프로그래밍 언어에서 실수, 정수, 소수 자료형 등의 여러 종류의
--데이터를 식별하는 타입으로서, 해당 자료형에 대한 가능한 값, 해당 자료형에서 수행을 할 수 있는 명령어, 데이터의 형태
-- 의미, 크기와 해당 자료형의 값이 저장되는 방식이다.

--문자형
--문자형 char 와 varchar2 비교
CREATE TABLE COMP (
    char_col CHAR(4),
    varchar_col VARCHAR2(4)
    );
INSERT INTO comp VALUES ('AA', 'AA');
INSERT INTO comp VALUES ('AAA', 'AAA');
INSERT INTO comp VALUES ('AAAA', 'AAAA');
COMMIT;
ROLLBACK;


SELECT * FROM comp;

SELECT * FROM comp
WHERE char_col = varchr_col;
-- char는 고정길이 데이터 타입, carchar2는 가변길이 데이터 타입



--숫자형 데이터 타입 NUMBER
--NUMBER(p,s) : p는 유효자리수 1~38, s는 소수점 유효자리수



--DATE 타입
SELECT hire_date, to_char(hire_date, 'YYYY-MM-DD') "날짜=>문자 형변환"
FROM employees;

SELECT *
FROM employees
WHERE hire_date < '2002/03/03';
--오라클에서 자동을 오른쪽 문자를 좌측에 날짜형 타입에 맞게 형변환 하여 비교함.




--테이블 만들기
CREATE TABLE ex_date(  --테이블 이름
    ex_id   NUMBER(2),  --열의 이름, 데이터타입
    start_date  DATE    DEFAULT SYSDATE   --티폴트는 입력안될시 디폴트 뒤의 값으로
    );
INSERT INTO ex_date(ex_id)
VALUES (1);
INSERT INTO ex_date(ex_id)
VALUES (2);
INSERT INTO ex_date(ex_id)
VALUES (3);
COMMIT;
SELECT * FROM ex_date;
DESC ex_date;



--테이블 삭제하기
DROP TABLE comp;
DROP TABLE copy_emp;



--예제1)
-- product_id(number 타입), product_name(varchar2 타입, 20자리), menu_date(date 타입) 열이 있는
--sample_product 이름의 테이블을 생성해 보세요.
CREATE TABLE sample_product(
    product_id  NUMBER,
    product_name    VARCHAR2(20),
    menu_date       DATE
    );
    
    
--예제2)
--위에서 만든 테이블을 삭제해 보세요. DESCRIBE 절로 테이블이 잘 삭제되었는지 확인하세요.
DROP TABLE sample_product;
DESC sample_product;



--제약조건
--제약 조건이랑 테이블 단위에서 데이터의 무결성을 보장해주는 규칙이다. 제약 조건은 테이블에 데이터가 입력
-- 수정, 삭제되거나 테이블이 삭제,변경될 경우 잘못된 트랜잭션이 수행되지 않도록 결함을 유발할 가능성이
--있는 작업을 방지하는 역할을 담당한다.
CREATE TABLE emp(
        eno     NUMBER(3) CONSTRAINT emp_emo_pk PRIMARY KEY,
        emp_name    VARCHAR2(20)
        );
DESC emp;
INSERT INTO emp 
VALUES (2, '양');
SELECT * FROM emp;

DROP TABLE emp;

--제약조건을 테이블 아래쪽에
CREATE TABLE emp(
        eno     NUMBER(3), 
        emp_name    VARCHAR2(20),
        CONSTRAINT emp_emo_pk PRIMARY KEY(eno)   --어딘지 알려줘야함
        );


--제약조건의 이름없이
CREATE TABLE emp1 (
        eno     NUMBER(3) PRIMARY KEY,
        emp_name    VARCHAR2(20)
        );
INSERT INTO emp1
VALUES (1, '박');

DROP TABLE emp1;



--NOT NULL / UK 유니크 : NULL값을 입력할 수 없다.
CREATE TABLE emp1(
        eno         NUMBER(3),
        emp_name    VARCHAR2(20) CONSTRAINT emp1_ename_nn NOT NULL,
        email       VARCHAR2(30) CONSTRAINT emp1_email_uk UNIQUE
        );
--NOT NULL 은 NULL 값을 넣을 수 없다.
INSERT INTO emp1
VALUES (1, NULL, 'hong@naver.com');
DESC emp1;

--UK 유니크는 동일한 값이 입력될 수 없다.
INSERT INTO emp1
VALUES (1, '홍길동', 'hong@naver.com');
INSERT INTO emp1
VALUES (2, '김유신', 'hong@naver.com');  --유니크에는 동일한 값을 넣을 수 없다.

-- CHECK 제약조건: WHERE절에 기술하는 조건 형식과 동일
CREATE TABLE emp2 (
        eno     NUMBER(3),
        emp_name    VARCHAR2(20) CONSTRAINT emp2_ename_nn NOT NULL,
        sal     NUMBER(10),
        CONSTRAINT emp2_sal_check CHECK (sal > 1000)
        );
INSERT INTO emp2
VALUES (1, '홍길동', 999);    --CHECK 조건에 위반돼서 안됨.

DROP TABLE emp;

CREATE TABLE emp (
        eno NUMBER(4)   PRIMARY KEY,   -- 제약조건 이름 생략
        ename VARCHAR2(20) NOT NULL,
        gno VARCHAR2(13)    UNIQUE CHECK (LENGTH(gno) >=8),
        gender VARCHAR2(5)  CHECK(gender IN ('women', 'man'))
        );
INSERT INTO emp 
VALUES (1, '김', '12345678', 'man');
INSERT INTO emp 
VALUES (2, '강', '123456789', 'woman');
INSERT INTO emp 
VALUES (3, '양', '123456789', 'human');


--예제1) members 라는 새 테이블을 만듭니다. (제약조건 이름은 생략가능)
CREATE TABLE members(
            member_id   NUMBER(2)   PRIMARY KEY,
            first_name  VARCHAR2(50)    NOT NULL,
            last_name   VARCHAR2(50)    NOT NULL,
            gender      VARCHAR2(5)     CHECK(gender IN ('women', 'man')),
            birth_day   DATE            DEFAULT SYSDATE,
            email       VARCHAR2(200)    UNIQUE  NOT NULL
            );
DESCRIBE members;



--외래키 (FK): FK가 정의된 자식 테이블이다. 참조되는 테이블을 부모 테이블이라고 한다.
--부모 테이블은 미리 생성되어 있어야 한다. 부모 테이블의 참조되는 컬럼에 존재하는 값 또는 NULL만 입력 가능

DROP TABLE dept;  
CREATE TABLE dept(
    dno     NUMBER(4),
    dname   VARCHAR2(20),
    CONSTRAINT dept_dno_pk  PRIMARY KEY(dno)  --기본키
    );
    
DROP TABLE emp;
CREATE TABLE emp(
    eno         NUMBER(4),
    emp_name    VARCHAR2(20),
    sal         NUMBER(10),
    dno         NUMBER(4),
    CONSTRAINT emp_eno_pk   PRIMARY KEY(eno),   --기본키
    CONSTRAINT emp_dno_fk   FOREIGN KEY(dno)    
    --REFERENCES dept(dno) ON DELETE CASCADE  --참조열 삭제시 자동삭제 (ON DELETE CASCADE)
    REFERENCES dept(dno) ON DELETE SET NULL --참조(dept table(dno))도 같이 적어야함
    -- NULL값 자동 입력
    );
    
INSERT INTO dept
VALUES (10, 'TEST1');
INSERT INTO dept
VALUES (20, 'TEST2');
INSERT INTO dept
VALUES (30, 'TEST3');
INSERT INTO dept
VALUES (40, 'TEST4');
INSERT INTO dept
VALUES (50, 'TEST5');

SELECT * FROM dept;

INSERT INTO emp VALUES (1010, 'Kim', 200, 10);
INSERT INTO emp VALUES (1020, 'Lee', 210, 20);
INSERT INTO emp VALUES (1030, 'Jung', 220, 30);
INSERT INTO emp VALUES (1040, 'Oh', 250, 40);
INSERT INTO emp VALUES (1050, 'King', 300, 50);

SELECT * FROM emp;

--외래키는 참조열의 값 이외에는 입력불가
INSERT INTO emp VALUES (1060, 'Kang', 500, 60);   -- dept 참조열에 50까지밖에 없음
--단, 널값은 입력가능
INSERT INTO emp VALUES (1060, 'Kang', 500, NULL);
            

--삭제시 에러 발생 (참조열의 값은 지우면 에러)
DELETE FROM dept
WHERE dno = 30;

-- 1 참조행 삭제시 자동 삭제
-- ON DELETE CASCASE
-- 2 참조행 삭제시 자동 널값
-- ON DELETE SET NULL








-- day7




--제약조건의 추가 및 수정
--클래스 테이블 생성
CREATE TABLE class (
        cno     VARCHAR2(2),
        cname   VARCHAR2 (50)
        );
INSERT INTO class 
VALUES ( '01', '데이터베이스');
INSERT INTO class 
VALUES ( '02', '자바');
SELECT * FROM class;


--학생테이블 생성
CREATE TABLE student(
    sno     VARCHAR2(4),
    sname   VARCHAR2 (50),
    cno     VARCHAR2(2)
    );
INSERT INTO student VALUES ('0414', '홍길동', '01');
INSERT INTO student VALUES ('0415', '임꺽정', '02');
INSERT INTO student VALUES ('0416', '이순신', '03');
COMMIT;
SELECT * FROM student;


--클래스 테이블에 '기본키' 추가
ALTER TABLE class
ADD CONSTRAINT class_cno_pk PRIMARY KEY (cno);


--기본키에는 NULL 값도 넣을 수 없음
INSERT INTO class 
VALUES ( NULL, '데이터베이스');


--클래스 테이블에 '유니크키' 추가
ALTER TABLE class
ADD CONSTRAINT class_cname_uk UNIQUE (cname);


-- 유니크는 중복안됨
INSERT INTO class 
VALUES ( '03', '데이터베이스');


--제약조건을 조회하는 명령문
SELECT *
FROM ALL_CONSTRAINTS -- 모든 제약조건
WHERE table_name = 'DEPARTMENTS';  -- 테이블명 입력시 대문자


-- 학생 테이블에 기본키 추가
ALTER TABLE student
ADD CONSTRAINT student_sno_pk PRIMARY KEY (sno);


-- 학생 테이블 sname NOT NULL 추가
-- NOT NULL 일경우만 MODIFY 사용
ALTER TABLE student
MODIFY sname CONSTRAINT student_sname_nn NOT NULL;


--학생 테이블에 외래키 추가 (참조하는 테이블과 열을 추가해야함)
ALTER TABLE student
ADD CONSTRAINT student_cno_fk FOREIGN KEY (cno) REFERENCES CLASS (cno);
SELECT * FROM class;
SELECT * FROM student;

--제약조건을 추가할때 이미 만들어진 테이블에 각 행의 데이터가 만족해야 추가된다.
UPDATE student SET cno = '01'
WHERE sno = '0416';



--제약조건의 삭제 : 2가지 방법이 있음
--제약조건의 이름으로 삭제
--CASCADE 옵션시 참조하는 외래키도 함께 삭제
ALTER TABLE  class
DROP CONSTRAINT class_cno_pk CASCADE;


--제약조건으로 삭제
ALTER TABLE class
DROP UNIQUE (cname); --클래스 테이블의 cname열의 유니크 제약조건 삭제
ALTER TABLE student
DROP PRIMARY KEY;  --기본키의 삭제


--테이블의 삭제
DROP TABLE class;
DROP TABLE student;



--테이블 컬럼(열)의 추가와 삭제


--1. 90번 부서의 직원들을 새테이블 EM_EMP에 원하는 열을 선택해 생성
CREATE TABLE E_EMP
AS SELECT employee_id, last_name, salary, department_id
FROM employees
WHERE department_id=90;
DESC E_EMP;
SELECT* FROM E_EMP;


--2. 열의 이름을 지정하여 E_EMP2 생성
CREATE TABLE E_EMP2 (emp_id, name, sal, dept_id)
AS SELECT employee_id, last_name, salary, department_id
FROM employees
WHERE department_id=90;
SELECT* FROM E_EMP2;


--열의 추가
SELECT * FROM E_EMP;

ALTER TABLE E_EMP
ADD (GENDER CHAR(1));  --젠더 열 추가 (입력 안된 값은 null)


-- 디폴트 값을 0으로 하는 열 추가
ALTER TABLE E_EMP
ADD (커미션 NUMBER DEFAULT 0 NOT NULL);


--두개의 열의 추가
ALTER TABLE E_EMP
ADD (날짜 DATE DEFAULT SYSDATE, 제작자 VARCHAR2(100) DEFAULT USER);


--열의 수정
SELECT * FROM E_EMP;

-- 데이터 사이즈 수정
ALTER TABLE E_EMP
MODIFY (제작자 VARCHAR2(200));  -- VARCHAR2 사이즈 100 -> 200으로
DESC E_EMP;

ALTER TABLE E_EMP
MODIFY (제작자 VARCHAR2(50));   -- VARCHAR2 사이즈 200 -> 50으로


ALTER TABLE E_EMP
MODIFY (제작자 VARCHAR2(1));  -- VARCHAR2 사이즈 50 -> 1으로  : 최소 2BYTE 아니면 에러

ALTER TABLE E_EMP
MODIFY (제작자 NUMBER);  -- 이미 문자형 데이터가 있기때문에 숫자형으로 에러

SELECT * FROM E_EMP;
DESC E_EMP;

-- NULL값인 경웨 입력된 값이 없기때문에 데이터 형식을 바꿀 수 있음
ALTER TABLE E_EMP
MODIFY (gender NUMBER);   


--제작자의 데이터 형식을 바꾸려 하면
UPDATE E_EMP
SET 제작자  = NULL;

ALTER TABLE E_EMP
MODIFY (제작자 NUMBER); 


--열의 삭제
ALTER TABLE E_EMP
DROP COLUMN 제작자;  --제작자 열을 삭제

--여러개의 열 삭제
ALTER TABLE E_EMP
DROP (GENDER, 커미션, 날짜, first_name);  

SELECT * FROM E_EMP;


--열의 이름 수정
ALTER TABLE E_EMP
RENAME COLUMN department_id TO 부서번호;
ALTER TABLE E_EMP
RENAME COLUMN salary TO 급여;
ALTER TABLE E_EMP
RENAME COLUMN employee_id TO 직원번호;
ALTER TABLE E_EMP
RENAME COLUMN last_name TO 이름;


--테이블의 이름 변경
RENAME E_EMP TO 직원테이블;



--예제1)
--employees 테이블의 job_id가 'ST_MAN'인 직원들을 새 테이블 stmans를 만들어 입력하라. 
--단, 테이블의 컬럼 이름은 id, job, sal (직원 테이블의 employee_id, job_id, salary)
CREATE TABLE stmans (id, job, sal)
AS SELECT employee_id, job_id, salary
FROM employees
WHERE job_id = 'ST_MAN';

SELECT * FROM stmans;





--day7





-- 단순한 뷰 EMP_V1 만들기
-- 하나이ㅡ 테이블, 함수나 그룹 사용 안함, DML 사용 가능
DROP VIEW EMP_V1; --미리 뷰 삭제 명령

-- employees 테이블에서 필요한 열들을 골라서 뷰로 생성
CREATE VIEW EMP_V1
AS
SELECT employee_id, first_name, last_name, email, hire_date, job_id
FROM employees;

--테이블처럼 SELECT 문 사용
SELECT* FROM EMP_V1;

DESC EMP_V1;

--테이블처럼 DML 사용가능 (뷰는 가상의 테이블 : 저장공간x) -> 원본 테이블에 입력됨
INSERT INTO EMP_V1 (employee_id, first_name, last_name, email, hire_date, job_id)
VALUES (333, 'David', 'King', 'Dking', SYSDATE, 'IT_PROG');


--뷰에 입력된 데이터 확인
SELECT * FROM EMP_V1
WHERE employee_id=333;
DESC employees;


--원본 테이블에서도 확인
SELECT * FROM employees
WHERE employee_id=333;


--뷰 삭제하기
DELETE FROM EMP_V1
WHERE employee_id = 333;
COMMIT;


--EMP_V2 만들기
CREATE VIEW EMP_V2
AS
SELECT employee_id 직원번호, first_name 이름, last_name 성, email, hire_date, job_id
FROM employees;

SELECT * FROM EMP_V2;


-- 3번째뷰 만들기
CREATE VIEW EMP_V3 ( 직원번호, 이름, 성, 이메일, 고용일자, 직종)
AS
SELECT employee_id , first_name , last_name , email, hire_date, job_id
FROM employees;

SELECT * FROM EMP_V1;
SELECT * FROM EMP_V2;
SELECT * FROM EMP_V3;
SELECT * FROM employees;

--DML 사용하기
INSERT INTO EMP_V3 ( 직원번호, 이름, 성, 이메일, 고용일자, 직종)
VALUES (334, 'Lara', 'Craft', 'Lara', SYSDATE, 'IT_PROG');


--복잡한 뷰로써 그룹함수를 사용하는 뷰는 DML 사용 불가
CREATE OR REPLACE VIEW 부서별_직원_보고서
AS
SELECT department_id 부서번호, COUNT(employee_id) 직원수,
MAX(salary) 최고급여,
MIN(salary) 최저급여,
ROUND(AVG(salary)) 평균급여
FROM employees
GROUP BY department_id
ORDER BY 부서번호;

SELECT * FROM 부서별_직원_보고서;


--읽기 전용뷰 (WITH READ ONLY)
CREATE OR REPLACE VIEW EMP_V_READ
AS
SELECT employee_id, first_name, last_name, email, hire_date, job_id
FROM employees
WHERE department_id=90
WITH READ ONLY;

SELECT * FROM EMP_V_READ;


-- DML 사용 불가
DELETE FROM EMP_V_READ;



--체크 옵션으로 뷰 만들기
CREATE or replace VIEW EMP_V_chq_const
AS
SELECT employee_id, first_name, last_name, email, hire_date, job_id, department_id
FROM employees
WHERE department_id=90
WITH CHECK OPTION;  --체크 옵션으로 현재 부서번호 90 일때만 수정 및 입력 가능

SELECT * FROM EMP_V_chq_const;


--90번 부서 일때만 DML 가능
INSERT INTO EMP_V_chq_const (employee_id, first_name, last_name, email, hire_date, job_id, department_id)
VALUES (444, 'FADI', 'ALI', 'FALI', SYSDATE, 'IT_PROG', 90);




--인덱스 확인하기
SELECT
    TABLE_NAME      테이블명,
    INDEX_NAME      인덱스이름,
    COLUMN_NAME     컬럼이름
FROM ALL_IND_COLUMNS   -- 오라클에서 자동 생성됨
WHERE TABLE_NAME ='DEPARTMENTS';   --테이블이름을 대문자로


DROP TABLE members;
--실습으로 테이블 만들기
CREATE TABLE members(
    member_id   INT,
    first_name  VARCHAR2(100) NOT NULL,
    last_name   VARCHAR2(100) NOT NULL,
    gender      CHAR(1) NOT NULL,
    dob         DATE NOT NULL,
    email       VARCHAR2(255) NOT NULL,
    PRIMARY KEY(member_id)
    );
DESC members;


--인덱스 확인하기
SELECT
    TABLE_NAME      테이블명,
    INDEX_NAME      인덱스이름,
    COLUMN_NAME     컬럼이름
FROM ALL_IND_COLUMNS   -- 오라클에서 자동 생성됨
WHERE TABLE_NAME ='MEMBERS';   --테이블 이름 대문자로

SELECT * FROM members
WHERE last_name = 'Harse';   --테이블 전체 검색

EXPLAIN PLAN FOR        --다음 나오는 SELECT 문을 실행하여 보고서 작성
SELECT * FROM members
WHERE last_name = 'Harse';

SELECT 
    PLAN_TABLE_OUTPUT    --설명문을 출력
FROM
    TABLE(DBMS_XPLAN.DISPLAY());
    
    

--인덱스 만들기
CREATE INDEX members_last_name_i
On members(last_name);


EXPLAIN PLAN FOR        --다음 나오는 SELECT 문을 실행하여 보고서 작성
SELECT * FROM members
WHERE last_name = 'Harse';


SELECT 
    PLAN_TABLE_OUTPUT    --설명문을 출력
FROM
    TABLE(DBMS_XPLAN.DISPLAY());


--인덱스 삭제하기 : 인덱스는 테이블이 drop/삭제 시 같이 삭제됨
DROP INDEX members_last_name_i;

SELECT * 
FROM members
WHERE first_name LIKE 'M%' AND last_name LIKE 'A%';


CREATE INDEX name_i
ON members(first_name, last_name);


EXPLAIN PLAN FOR        --다음 나오는 SELECT 문을 실행하여 보고서 작성
SELECT * FROM members
WHERE first_name LIKE 'M%' AND last_name LIKE 'A%';


SELECT 
    PLAN_TABLE_OUTPUT    --설명문을 출력
FROM
    TABLE(DBMS_XPLAN.DISPLAY());

-- 인덱스 삭세하기
DROP INDEX name_i;


